package ingress

import (
	"context"
	"errors"
	"fmt"
	"log/slog"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strings"
	"time"

	"github.com/splax/localvercel/api/internal/domain"
	"github.com/splax/localvercel/pkg/config"
)

var slugExpr = regexp.MustCompile(`[^a-z0-9-]+`)

// Service manages nginx configuration for running deployments.
// The service writes one configuration file per project and triggers an optional reload command.
// It intentionally keeps state minimal to avoid accidental removal of unrelated configuration files.
type Service struct {
	configDir     string
	domainSuffix  string
	reloadCommand string
	logger        *slog.Logger
	docker        *dockerReloader
}

// New constructs an ingress service from configuration.
func New(cfg config.APIConfig, logger *slog.Logger) *Service {
	dir := strings.TrimSpace(cfg.NginxConfigPath)
	suffix := strings.TrimSpace(cfg.IngressDomainSuffix)
	if suffix == "" {
		suffix = ".local.peep"
	}
	service := &Service{
		configDir:     dir,
		domainSuffix:  suffix,
		reloadCommand: strings.TrimSpace(cfg.NginxReloadCommand),
		logger:        logger.With("component", "ingress"),
	}
	if service.reloadCommand == "" && strings.TrimSpace(cfg.NginxContainerName) != "" {
		reloader, err := newDockerReloader(strings.TrimSpace(cfg.NginxContainerName))
		if err != nil {
			service.logger.Warn("failed to initialise docker-based nginx reloader", "error", err)
		} else {
			service.docker = reloader
		}
	}
	return service
}

// Close releases underlying resources.
func (s *Service) Close() {
	if s == nil || s.docker == nil {
		return
	}
	if err := s.docker.Close(); err != nil {
		s.logger.Warn("failed to close docker reloader", "error", err)
	}
}

// Apply renders or removes nginx configuration based on the active containers for a project.
func (s *Service) Apply(ctx context.Context, project domain.Project, containers []domain.ProjectContainer) error {
	if s == nil {
		return errors.New("ingress service not initialised")
	}
	if strings.TrimSpace(s.configDir) == "" {
		s.logger.Warn("ingress config directory not configured, skipping", "project_id", project.ID)
		return nil
	}
	if err := os.MkdirAll(s.configDir, 0o755); err != nil {
		return fmt.Errorf("ensure nginx config dir: %w", err)
	}

	container, ok := selectActiveContainer(containers)
	if !ok {
		s.logger.Info("no active containers; removing ingress config", "project_id", project.ID)
		return s.removeConfig(ctx, project)
	}

	if err := s.writeConfig(project, container); err != nil {
		return err
	}
	return s.reload(ctx, project.ID)
}

// Remove deletes nginx configuration for a project if present and reloads nginx.
func (s *Service) Remove(ctx context.Context, project domain.Project) error {
	if s == nil {
		return errors.New("ingress service not initialised")
	}
	if strings.TrimSpace(s.configDir) == "" {
		return nil
	}
	if err := s.removeConfig(ctx, project); err != nil {
		return err
	}
	return s.reload(ctx, project.ID)
}

func (s *Service) writeConfig(project domain.Project, container domain.ProjectContainer) error {
	path := s.configPath(project)
	temp, err := os.CreateTemp(s.configDir, ".tmp-*.conf")
	if err != nil {
		return fmt.Errorf("create temp config: %w", err)
	}
	defer func() {
		_ = os.Remove(temp.Name())
	}()

	host := container.HostIP
	if strings.TrimSpace(host) == "" || host == "0.0.0.0" {
		host = "host.docker.internal"
	}

	config := fmt.Sprintf(`# Auto-generated by peep at %s
server {
    listen 80;
    server_name %s;
    location / {
        proxy_pass http://%s:%d;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
`, time.Now().UTC().Format(time.RFC3339), s.serverName(project), host, container.HostPort)

	if err := os.WriteFile(temp.Name(), []byte(config), 0o644); err != nil {
		return fmt.Errorf("write temp config: %w", err)
	}

	if err := os.Rename(temp.Name(), path); err != nil {
		return fmt.Errorf("replace nginx config: %w", err)
	}

	s.logger.Info("ingress config updated", "project_id", project.ID, "host", host, "port", container.HostPort, "path", path)
	return nil
}

func (s *Service) removeConfig(ctx context.Context, project domain.Project) error {
	path := s.configPath(project)
	if _, err := os.Stat(path); err != nil {
		if os.IsNotExist(err) {
			return nil
		}
		return fmt.Errorf("stat nginx config: %w", err)
	}
	if err := os.Remove(path); err != nil {
		return fmt.Errorf("remove nginx config: %w", err)
	}
	s.logger.Info("ingress config removed", "project_id", project.ID, "path", path)
	return nil
}

func (s *Service) reload(ctx context.Context, projectID string) error {
	if s.reloadCommand == "" {
		if s.docker == nil {
			s.logger.Debug("nginx reload command not configured, skipping", "project_id", projectID)
			return nil
		}
		if err := s.docker.Reload(ctx); err != nil {
			s.logger.Error("nginx docker reload failed", "project_id", projectID, "error", err)
			return err
		}
		s.logger.Info("nginx reload triggered via docker", "project_id", projectID)
		return nil
	}
	cmd := exec.CommandContext(ctx, "sh", "-c", s.reloadCommand)
	output, err := cmd.CombinedOutput()
	if err != nil {
		s.logger.Error("nginx reload failed", "project_id", projectID, "error", err, "output", string(output))
		return fmt.Errorf("reload nginx: %w", err)
	}
	if len(output) > 0 {
		s.logger.Debug("nginx reload output", "project_id", projectID, "output", string(output))
	}
	s.logger.Info("nginx reloaded", "project_id", projectID)
	return nil
}

func (s *Service) configPath(project domain.Project) string {
	filename := fmt.Sprintf("project-%s.conf", s.projectSlug(project))
	return filepath.Join(s.configDir, filename)
}

func (s *Service) projectSlug(project domain.Project) string {
	base := strings.ToLower(strings.TrimSpace(project.Name))
	if base == "" {
		base = project.ID
	}
	base = strings.ToLower(base)
	base = slugExpr.ReplaceAllString(base, "-")
	base = strings.Trim(base, "-")
	if base == "" {
		base = project.ID
	}
	return base
}

func (s *Service) serverName(project domain.Project) string {
	return s.projectSlug(project) + s.domainSuffix
}

func selectActiveContainer(containers []domain.ProjectContainer) (domain.ProjectContainer, bool) {
	for _, c := range containers {
		if strings.ToLower(strings.TrimSpace(c.Status)) != "running" && strings.ToLower(strings.TrimSpace(c.Status)) != "success" {
			continue
		}
		if c.HostPort <= 0 {
			continue
		}
		return c, true
	}
	return domain.ProjectContainer{}, false
}
