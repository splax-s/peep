package ingress

import (
	"context"
	"errors"
	"fmt"
	"log/slog"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
	"time"

	"github.com/splax/localvercel/api/internal/domain"
	"github.com/splax/localvercel/pkg/config"
)

var slugExpr = regexp.MustCompile(`[^a-z0-9-]+`)

// Service manages nginx configuration for running deployments.
// The service writes one configuration file per project and triggers an optional reload command.
// It intentionally keeps state minimal to avoid accidental removal of unrelated configuration files.
type Service struct {
	configDir        string
	domainSuffix     string
	reloadCommand    string
	logger           *slog.Logger
	docker           *dockerReloader
	acmeRoot         string
	healthPath       string
	readinessTimeout time.Duration
}

// New constructs an ingress service from configuration.
func New(cfg config.APIConfig, logger *slog.Logger) *Service {
	dir := strings.TrimSpace(cfg.NginxConfigPath)
	suffix := strings.TrimSpace(cfg.IngressDomainSuffix)
	if suffix == "" {
		suffix = ".local.peep"
	}
	service := &Service{
		configDir:     dir,
		domainSuffix:  suffix,
		reloadCommand: strings.TrimSpace(cfg.NginxReloadCommand),
		logger:        logger.With("component", "ingress"),
	}
	service.acmeRoot = strings.TrimSpace(cfg.IngressACMERoot)
	if service.acmeRoot == "" {
		service.acmeRoot = "/var/www/acme"
	}
	healthPath := strings.TrimSpace(cfg.IngressHealthPath)
	if healthPath == "" {
		healthPath = "/__peep_healthz"
	}
	if !strings.HasPrefix(healthPath, "/") {
		healthPath = "/" + healthPath
	}
	service.healthPath = healthPath
	if cfg.IngressReadinessTimeout <= 0 {
		service.readinessTimeout = 2 * time.Second
	} else {
		service.readinessTimeout = cfg.IngressReadinessTimeout
	}
	containerName := strings.TrimSpace(cfg.NginxContainerName)
	if containerName != "" {
		reloader, err := newDockerReloader(containerName)
		if err != nil {
			service.logger.Warn("failed to initialise docker-based nginx reloader", "error", err)
		} else {
			service.docker = reloader
		}
	}
	return service
}

// Close releases underlying resources.
func (s *Service) Close() {
	if s == nil || s.docker == nil {
		return
	}
	if err := s.docker.Close(); err != nil {
		s.logger.Warn("failed to close docker reloader", "error", err)
	}
}

// Apply renders or removes nginx configuration based on the active containers for a project.
func (s *Service) Apply(ctx context.Context, project domain.Project, containers []domain.ProjectContainer) error {
	if s == nil {
		return errors.New("ingress service not initialised")
	}
	if strings.TrimSpace(s.configDir) == "" {
		s.logger.Warn("ingress config directory not configured, skipping", "project_id", project.ID)
		return nil
	}
	if err := os.MkdirAll(s.configDir, 0o755); err != nil {
		return fmt.Errorf("ensure nginx config dir: %w", err)
	}

	ready := s.readyContainers(ctx, containers)
	if len(ready) == 0 {
		s.logger.Info("no ready containers; removing ingress config", "project_id", project.ID)
		return s.removeConfig(ctx, project)
	}

	if err := s.writeConfig(project, ready); err != nil {
		return err
	}
	return s.reload(ctx, project.ID)
}

// Remove deletes nginx configuration for a project if present and reloads nginx.
func (s *Service) Remove(ctx context.Context, project domain.Project) error {
	if s == nil {
		return errors.New("ingress service not initialised")
	}
	if strings.TrimSpace(s.configDir) == "" {
		return nil
	}
	if err := s.removeConfig(ctx, project); err != nil {
		return err
	}
	return s.reload(ctx, project.ID)
}

func (s *Service) writeConfig(project domain.Project, containers []domain.ProjectContainer) error {
	path := s.configPath(project)
	temp, err := os.CreateTemp(s.configDir, ".tmp-*.conf")
	if err != nil {
		return fmt.Errorf("create temp config: %w", err)
	}
	defer func() {
		_ = os.Remove(temp.Name())
	}()

	upstreamName := fmt.Sprintf("upstream_%s", s.projectSlug(project))
	var builder strings.Builder
	builder.WriteString(fmt.Sprintf("# Auto-generated by peep at %s\n", time.Now().UTC().Format(time.RFC3339)))
	builder.WriteString(fmt.Sprintf("upstream %s {\n", upstreamName))
	for _, container := range containers {
		host := s.resolveHost(container.HostIP)
		builder.WriteString(fmt.Sprintf("    server %s:%d max_fails=3 fail_timeout=30s;\n", host, container.HostPort))
	}
	builder.WriteString("}\n\n")

	builder.WriteString("server {\n")
	builder.WriteString("    listen 80;\n")
	builder.WriteString(fmt.Sprintf("    server_name %s;\n", s.serverName(project)))
	builder.WriteString("    error_page 404 /__peep_404.html;\n")
	builder.WriteString("    error_page 502 503 504 /__peep_502.html;\n")
	if s.acmeRoot != "" {
		builder.WriteString("    location /.well-known/acme-challenge/ {\n")
		builder.WriteString(fmt.Sprintf("        root %s;\n", s.acmeRoot))
		builder.WriteString("        try_files $uri =404;\n")
		builder.WriteString("    }\n")
	}
	healthPath := s.healthPath
	if healthPath != "" {
		timeout := formatDuration(s.readinessTimeout)
		builder.WriteString(fmt.Sprintf("    location = %s {\n", healthPath))
		builder.WriteString(fmt.Sprintf("        proxy_pass http://%s;\n", upstreamName))
		builder.WriteString("        proxy_http_version 1.1;\n")
		builder.WriteString("        proxy_set_header Host $host;\n")
		builder.WriteString("        proxy_set_header X-Real-IP $remote_addr;\n")
		builder.WriteString("        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n")
		builder.WriteString("        proxy_set_header X-Forwarded-Proto $scheme;\n")
		builder.WriteString(fmt.Sprintf("        proxy_connect_timeout %s;\n", timeout))
		builder.WriteString(fmt.Sprintf("        proxy_read_timeout %s;\n", timeout))
		builder.WriteString("    }\n")
	}
	builder.WriteString("    location / {\n")
	builder.WriteString(fmt.Sprintf("        proxy_pass http://%s;\n", upstreamName))
	builder.WriteString("        proxy_http_version 1.1;\n")
	builder.WriteString("        proxy_set_header Host $host;\n")
	builder.WriteString("        proxy_set_header X-Real-IP $remote_addr;\n")
	builder.WriteString("        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n")
	builder.WriteString("        proxy_set_header X-Forwarded-Proto $scheme;\n")
	builder.WriteString("        proxy_next_upstream error timeout http_502 http_503 http_504;\n")
	builder.WriteString("    }\n")
	builder.WriteString("    location = /__peep_404.html {\n")
	builder.WriteString("        internal;\n")
	builder.WriteString("        alias /etc/nginx/errors/404.html;\n")
	builder.WriteString("    }\n")
	builder.WriteString("    location = /__peep_502.html {\n")
	builder.WriteString("        internal;\n")
	builder.WriteString("        alias /etc/nginx/errors/502.html;\n")
	builder.WriteString("    }\n")
	builder.WriteString("}\n")

	if err := os.WriteFile(temp.Name(), []byte(builder.String()), 0o644); err != nil {
		return fmt.Errorf("write temp config: %w", err)
	}

	if err := os.Rename(temp.Name(), path); err != nil {
		return fmt.Errorf("replace nginx config: %w", err)
	}

	var endpoints []string
	for _, container := range containers {
		endpoints = append(endpoints, fmt.Sprintf("%s:%d", s.resolveHost(container.HostIP), container.HostPort))
	}
	s.logger.Info("ingress config updated", "project_id", project.ID, "endpoints", strings.Join(endpoints, ","), "path", path)
	return nil
}

func (s *Service) removeConfig(ctx context.Context, project domain.Project) error {
	path := s.configPath(project)
	if _, err := os.Stat(path); err != nil {
		if os.IsNotExist(err) {
			return nil
		}
		return fmt.Errorf("stat nginx config: %w", err)
	}
	if err := os.Remove(path); err != nil {
		return fmt.Errorf("remove nginx config: %w", err)
	}
	s.logger.Info("ingress config removed", "project_id", project.ID, "path", path)
	return nil
}

func (s *Service) reload(ctx context.Context, projectID string) error {
	if s.reloadCommand != "" {
		cmd := exec.CommandContext(ctx, "sh", "-c", s.reloadCommand)
		output, err := cmd.CombinedOutput()
		if err == nil {
			if len(output) > 0 {
				s.logger.Debug("nginx reload output", "project_id", projectID, "output", string(output))
			}
			s.logger.Info("nginx reloaded", "project_id", projectID)
			return nil
		}

		s.logger.Error("nginx reload failed", "project_id", projectID, "error", err, "output", string(output))

		var exitErr *exec.ExitError
		if s.docker != nil && errors.As(err, &exitErr) && exitErr.ExitCode() == 127 {
			s.logger.Warn("reload command missing; falling back to docker reload", "project_id", projectID)
			if derr := s.reloadWithDocker(ctx, projectID); derr == nil {
				return nil
			} else {
				return fmt.Errorf("reload nginx via docker: %w", derr)
			}
		}
		return fmt.Errorf("reload nginx: %w", err)
	}
	return s.reloadWithDocker(ctx, projectID)
}

func (s *Service) reloadWithDocker(ctx context.Context, projectID string) error {
	if s.docker == nil {
		s.logger.Debug("nginx reload mechanism not configured", "project_id", projectID)
		return nil
	}
	if err := s.docker.Reload(ctx); err != nil {
		s.logger.Error("nginx docker reload failed", "project_id", projectID, "error", err)
		return err
	}
	s.logger.Info("nginx reload triggered via docker", "project_id", projectID)
	return nil
}

func (s *Service) configPath(project domain.Project) string {
	filename := fmt.Sprintf("project-%s.conf", s.projectSlug(project))
	return filepath.Join(s.configDir, filename)
}

func (s *Service) projectSlug(project domain.Project) string {
	base := strings.ToLower(strings.TrimSpace(project.Name))
	if base == "" {
		base = project.ID
	}
	base = strings.ToLower(base)
	base = slugExpr.ReplaceAllString(base, "-")
	base = strings.Trim(base, "-")
	if base == "" {
		base = project.ID
	}
	return base
}

func (s *Service) serverName(project domain.Project) string {
	return s.projectSlug(project) + s.domainSuffix
}

func (s *Service) readyContainers(ctx context.Context, containers []domain.ProjectContainer) []domain.ProjectContainer {
	if len(containers) == 0 {
		return nil
	}
	var ready []domain.ProjectContainer
	for _, c := range containers {
		if err := ctx.Err(); err != nil {
			return ready
		}
		status := strings.ToLower(strings.TrimSpace(c.Status))
		if status != "running" && status != "success" {
			continue
		}
		if c.HostPort <= 0 {
			continue
		}
		ready = append(ready, c)
	}
	sort.SliceStable(ready, func(i, j int) bool {
		if ready[i].UpdatedAt.Equal(ready[j].UpdatedAt) {
			return ready[i].ID < ready[j].ID
		}
		return ready[i].UpdatedAt.Before(ready[j].UpdatedAt)
	})
	return ready
}

func (s *Service) resolveHost(ip string) string {
	ip = strings.TrimSpace(ip)
	switch ip {
	case "", "0.0.0.0", "127.0.0.1":
		return "host.docker.internal"
	default:
		return ip
	}
}

func formatDuration(d time.Duration) string {
	if d <= 0 {
		return "0s"
	}
	if d%time.Second == 0 {
		return fmt.Sprintf("%ds", int(d/time.Second))
	}
	if d%time.Millisecond == 0 {
		return fmt.Sprintf("%dms", int(d/time.Millisecond))
	}
	return d.String()
}
